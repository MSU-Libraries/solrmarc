package playground.solrmarc.index.specification.conditional;

import java_cup.runtime.*;
import java.util.List;
import java.util.ArrayList;
import playground.solrmarc.index.specification.conditional.ConditionalScanner;
import playground.solrmarc.index.specification.*;

parser code {:
    static ConditionalScanner scanner;
    static boolean parser_debug;
    static List<String> parser_errors = null;
    public static void setParserDebug(boolean b) { parser_debug = b; } 
    public static boolean shouldParserDebug()    { return(parser_debug); }
    public ConditionalParser(boolean debug) 
    { 
        super(new ComplexSymbolFactory());
        parser_debug = debug;
        this.scanner = new ConditionalScanner((ComplexSymbolFactory)getSymbolFactory());
        this.setScanner(this.scanner);
    }
    
    public Specification parse(String strToParse, boolean debug)
    {
        Symbol parse_tree = null;
        Specification result = null;
        parser_errors = new ArrayList<String>();
        scanner.startParse(strToParse);
        try{
            if (debug)
                parse_tree = this.debug_parse();
            else
                parse_tree = this.parse();
        }
        catch (Exception e) {
            parser_errors.add("Exception "+e.toString());
            //parser_errors.add(" Input Specification "+strToParse);
        } 
        finally {
        }
        if (parse_tree != null) 
        {
            result = (Specification) parse_tree.value;
            if (result != null)
            {
            	result.setSpecLabel(strToParse);
            }
        }
        return(result);     
    }
   
    public Specification parse(String strToParse)
    {
        return(parse(strToParse, parser_debug));
    }
    
    public static final List<String> getErrors()
    {
    	if (scanner.getScannerErrors().size() == 0)
    		return(parser_errors);
    	List<String> allErrors = new ArrayList<String>();
    	allErrors.addAll(parser_errors);
    	allErrors.addAll(scanner.getScannerErrors());
    	return(allErrors);
    }
    
    public static final void addError(String errorMsg)
    {
        parser_errors.add(errorMsg);
    }
:}

/* define how to connect to the scanner! */



terminal COLON, LBRACE, RBRACE, QUESTION, AND, OR, NOT, LPAREN, RPAREN, EQU, NEQ, GT, LT, MATCH;
terminal String SUBFIELD, IND, FIELDSPEC, SUBFIELDSPEC, POSITION, QUOTEDSTR, CHAR, NUMBER;
 
non terminal CompositeSpecification field_spec, field_spec_simple, field_spec_part;
non terminal SingleSpecification field_spec_part_complex, field_spec_part_simple;
non terminal Condition expr, expr_part;
non terminal String value;
non terminal Integer  op;

precedence nonassoc NOT;
precedence left AND;
precedence left OR;

start with field_spec;

field_spec ::= field_spec:s COLON field_spec_part:s1						{: s.addSpec(s1); RESULT = s; :}
             | field_spec_part:s											{: RESULT = new CompositeSpecification(s); :}
             | error														{: RESULT = null; :}
             ;
             
field_spec_simple ::= field_spec_simple:s COLON field_spec_part_simple:s1   {: s.addSpec(s1); RESULT = s; :}
                    | field_spec_part_simple:s                              {: RESULT = new CompositeSpecification(s); :}
                    ;

field_spec_part ::= LBRACE field_spec_simple:s RBRACE QUESTION expr:e       {: s.addConditional(e); RESULT = s; :}
                  | field_spec_part_complex:s                               {: RESULT = new CompositeSpecification(s); :}
                  ;
                                    
field_spec_part_complex ::= field_spec_part_simple:s QUESTION expr:e        {: RESULT = s; s.addConditional(e); :}
                          | field_spec_part_simple:s                        {: RESULT = s; :}
                          ;
                          
field_spec_part_simple ::= FIELDSPEC:f SUBFIELDSPEC:sf                      {: RESULT = AbstractSpecificationFactory.makeSingleSpecification(f, sf); :} 
                         | FIELDSPEC:f SUBFIELDSPEC:sf POSITION:p           {: RESULT = AbstractSpecificationFactory.makeSingleSpecification(f, sf, p); :} 
                         | FIELDSPEC:f POSITION:p                           {: RESULT = AbstractSpecificationFactory.makeSingleSpecification(f, null, p); :} 
                         | FIELDSPEC:f                                      {: RESULT = AbstractSpecificationFactory.makeSingleSpecification(f, null); :} 
                         ;
                         
expr ::= expr:e1 AND expr:e2 				{: RESULT = new ConditionComposite(e1, e2, sym.AND);  :}
       | expr:e1 OR expr:e2					{: RESULT = new ConditionComposite(e1, e2, sym.OR);  :} 
       | NOT expr:e							{: RESULT = new ConditionComposite(e, null, sym.NOT); :}
       | LPAREN expr:e RPAREN 				{: RESULT = e; :}
       | expr_part:e						{: RESULT = e; :}
       ;
       
expr_part ::= SUBFIELD:s1 op:i value:s2		                {: RESULT = new ConditionSubfield(s1, s2, ((int)i)); :} 
            | IND:s1 op:i value:s2			                {: RESULT = new ConditionIndicator(s1, s2, ((int)i)); :} 
            | POSITION:s1 op:i value:s2		                {: RESULT = new ConditionPosition(s1, s2, ((int)i)); :} 
            | FIELDSPEC:s1 SUBFIELD:s2 op:i value:s3		{: RESULT = new ConditionSubfield(s1, s2, s3, ((int)i)); :} 
            | FIELDSPEC:s1 IND:s2 op:i value:s3			    {: RESULT = new ConditionIndicator(s1, s2, s3, ((int)i)); :} 
            | FIELDSPEC:s1 POSITION:s2 op:i value:s3		{: RESULT = new ConditionPosition(s1, s2, s3, ((int)i)); :} 
            ;
op ::= EQU                                  {: RESULT = new Integer(sym.EQU); :}
     | NEQ                                  {: RESULT = new Integer(sym.NEQ); :}
     | MATCH                                {: RESULT = new Integer(sym.MATCH); :}
     | LT                                   {: RESULT = new Integer(sym.LT); :}
     | GT                                   {: RESULT = new Integer(sym.GT); :}
     ;
     
value ::= QUOTEDSTR:s						{: RESULT = s; :} 
        | CHAR:s							{: RESULT = s; :}
        | NUMBER:s							{: RESULT = s; :} 
        ;
  
 