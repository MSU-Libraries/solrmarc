import java_cup.runtime.*;
import java.util.List;
import java.util.Set;

import org.apache.log4j.Logger;

import java.util.ArrayList;
import java.util.Collections;
import playground.solrmarc.index.collector.MultiValueCollector;
import playground.solrmarc.index.extractor.AbstractMultiValueExtractor;
import playground.solrmarc.index.extractor.AbstractSingleValueExtractor;
import playground.solrmarc.index.extractor.MultiValueWrapperSingleValueExtractor;
import playground.solrmarc.index.extractor.impl.constant.ConstantMultiValueExtractor;
import playground.solrmarc.index.extractor.impl.date.DateValueExtractorFactory;
import playground.solrmarc.index.extractor.impl.direct.DirectMultiValueExtractor;
import playground.solrmarc.index.extractor.impl.fullrecord.FullRecordValueExtractorFactory;
import playground.solrmarc.index.mapping.AbstractMultiValueMapping;
import playground.solrmarc.index.mapping.AbstractValueMappingFactory;
import playground.solrmarc.index.specification.conditional.*;
import playground.solrmarc.index.utils.ReflectionUtils;
import playground.solrmarc.index.utils.StringReader;
import playground.solrmarc.index.specification.*;

parser code {:
    private final static Logger logger = Logger.getLogger(ValueIndexerFactory.class);

    static FullConditionalScanner scanner;
    static boolean parser_debug;
    static List<String> parser_errors = null;
    static FullRecordValueExtractorFactory fullFactory = new FullRecordValueExtractorFactory();
    static DateValueExtractorFactory dateFactory = new DateValueExtractorFactory();
    static MultiValueCollector MULTI_VALUE_COLLECTOR = new MultiValueCollector();
    private List<AbstractValueMappingFactory> mappingFactories = null;
    
    public static void setParserDebug(boolean b) { parser_debug = b; } 
    public static boolean shouldParserDebug()    { return(parser_debug); }
    public FullConditionalParser(boolean debug) throws IllegalAccessException, InstantiationException 
    { 
        super(debug ? new VerboseSymbolFactory() : new ComplexSymbolFactory());
        parser_debug = debug;
        this.scanner = new FullConditionalScanner((ComplexSymbolFactory)getSymbolFactory());
        this.setScanner(this.scanner);
        this.mappingFactories = createMappingFactories(ReflectionUtils.getMappingFactoryClasses());
    }
    
    public MultiValueIndexer parse(String strToParse, boolean debug)
    {
        Symbol parse_tree = null;
        MultiValueIndexer result = null;
        parser_errors = new ArrayList<String>();
        scanner.startParse(strToParse);
        try{
            if (debug)
                parse_tree = this.debug_parse();
            else
                parse_tree = this.parse();
        }
        catch (Exception e) {
            parser_errors.add("Exception "+e.toString());
            //parser_errors.add(" Input Specification "+strToParse);
        } 
        finally {
        }
        if (parse_tree != null) 
        {
            result = (MultiValueIndexer) parse_tree.value;
//            if (result != null)
//            {
//            	result.setSpecLabel(strToParse);
//            }
        }
        return(result);     
    }
   
    public MultiValueIndexer parse(String strToParse)
    {
        return(parse(strToParse, parser_debug));
    }
    
    private static String toDelimitedString(String[] strs, String delimiter)
    {
        StringBuilder strb = new StringBuilder();
        for (String str : strs)
        {
          strb.append(str).append(delimiter);
        }
        return strb.substring(0, strb.length() - delimiter.length());
     }
    
    private AbstractMultiValueMapping createMultiValueMapping(List<String> mapParams)
    {
    	if (this.mappingFactories == null) 
        {
    		try {
				this.mappingFactories = createMappingFactories(ReflectionUtils.getMappingFactoryClasses());
			}
    		catch (IllegalAccessException | InstantiationException e) {
    			 throw new IndexerSpecException("Could not instantiate mapping factory\n" + mappingFactories.toString().replaceAll(",", ",\n"));
			}
        }
    	String[] mapParts = mapParams.toArray(new String[0]);
    	for (final AbstractValueMappingFactory mappingFactory : mappingFactories)
        {
            if (mappingFactory.canHandle(mapParts[0]))
            {
                return mappingFactory.createMultiValueMapping(mapParts);
            }
        }
        throw new IndexerSpecException("Could not handle impl: " + toDelimitedString(mapParts, " ") + "\nLoaded impl factories:\n" + mappingFactories.toString().replaceAll(",", ",\n"));
    }

    private List<AbstractValueMappingFactory> createMappingFactories(final Set<Class<? extends AbstractValueMappingFactory>> factoryClasses) throws IllegalAccessException, InstantiationException
    {
        final List<AbstractValueMappingFactory> factories = new ArrayList<>(factoryClasses.size());
        for (final Class<? extends AbstractValueMappingFactory> extractorFactoryClass : factoryClasses)
        {
            logger.trace("Create value mapping factory for  s " + extractorFactoryClass);
            final AbstractValueMappingFactory factory = extractorFactoryClass.newInstance();
            factories.add(factory);
        }
        return factories;
    }

    public static final List<String> getErrors()
    {
    	if (scanner.getScannerErrors().size() == 0)
    		return(parser_errors);
    	List<String> allErrors = new ArrayList<String>();
    	allErrors.addAll(parser_errors);
    	allErrors.addAll(scanner.getScannerErrors());
    	return(allErrors);
    }
    
    public static final void addError(String errorMsg)
    {
        parser_errors.add(errorMsg);
    }
:}

/* define how to connect to the scanner! */

terminal COMMA, SCRIPT, CUSTOM, JAVA;
terminal String FIELDNAME, FULLRECORD, DATE, IDENTIFIER;
terminal COLON, LBRACE, RBRACE, QUESTION, AND, OR, NOT, LPAREN, RPAREN, EQU, NEQ, GT, LT, MATCH;
terminal String SUBFIELD, IND, FIELDSPEC, SUBFIELDSPEC, POSITION, QUOTEDSTR, CHAR, NUMBER;
 
non terminal AbstractValueIndexer<?> index_spec;
non terminal AbstractMultiValueExtractor extractor, custom_extractor; 
non terminal List<AbstractMultiValueMapping> mapping_specs;
non terminal AbstractMultiValueMapping mapping_spec;
non terminal List<String> field_names, strings, method_plus_params, params, custom_map_spec;
non terminal CompositeSpecification field_spec, field_spec_simple, field_spec_part;
non terminal SingleSpecification field_spec_part_complex, field_spec_part_simple;
non terminal Condition expr, expr_part;
non terminal String value;
non terminal Integer  op;

precedence nonassoc NOT;
precedence left AND;
precedence left OR;

start with index_spec;

index_spec ::= field_names:s EQU extractor:e COMMA mapping_specs:m          {: RESULT = new MultiValueIndexer(s, e, m, MULTI_VALUE_COLLECTOR); :}
             | field_names:s EQU extractor:e                                {: RESULT = new MultiValueIndexer(s, e, new AbstractMultiValueMapping[0], MULTI_VALUE_COLLECTOR); :}
             ; 
             
field_names ::= field_names:s COMMA FIELDNAME:n                             {: RESULT = s; s.add(n); :}
              | FIELDNAME:n                                                 {: RESULT = new ArrayList<String>(); RESULT.add(n); :}
              ;
              
extractor ::= strings:l                                                     {: RESULT = new ConstantMultiValueExtractor(l); :}
            | field_spec:fs                                                 {: RESULT = new DirectMultiValueExtractor(fs);  :} 
            | FULLRECORD:s                                                  {: RESULT = new MultiValueWrapperSingleValueExtractor((AbstractSingleValueExtractor)fullFactory.createExtractor("CUP Parser", new StringReader(s))); :}
            | DATE:s                                                        {: RESULT = (AbstractMultiValueExtractor)dateFactory.createExtractor("CUP Parser", new StringReader(s)); :}
            | custom_extractor:e               
            | error														    {: RESULT = null; :}
            ;
            
strings ::= strings:l OR QUOTEDSTR:s                                        {: RESULT = l; l.add(s); :}
          | QUOTEDSTR:s                                                     {: RESULT = new ArrayList<String>(); RESULT.add(s); :}
          ;
          
custom_extractor ::= CUSTOM:t LPAREN IDENTIFIER:m RPAREN COMMA method_plus_params:l   
                  |  JAVA:t LPAREN IDENTIFIER:m RPAREN COMMA method_plus_params:l
                  |  SCRIPT:t LPAREN IDENTIFIER:m RPAREN COMMA method_plus_params:l
                  ;

mapping_specs ::= mapping_specs:l COMMA mapping_spec:m               		{: RESULT = l; l.add(m); :}
               |  mapping_spec:m                                        	{: RESULT = new ArrayList<AbstractMultiValueMapping>(); RESULT.add(m); :}
               ;  
               
mapping_spec  ::= method_plus_params:l               						{: RESULT = createMultiValueMapping(l); :}
               |  custom_map_spec:l                                         {: RESULT = createMultiValueMapping(l); :}
               ;  

custom_map_spec ::=  IDENTIFIER:s LPAREN IDENTIFIER:s1  IDENTIFIER:s2 RPAREN 
															               	{: RESULT = new ArrayList<String>(); RESULT.add(s); RESULT.add(s1); RESULT.add(s2); :}
				  |  IDENTIFIER:s LPAREN IDENTIFIER:s1  IDENTIFIER:s2 LPAREN params:l RPAREN RPAREN 
															               	{: RESULT = l; RESULT.add(0, s); RESULT.add(1, s1); RESULT.add(2, s2); :}
                  ;

method_plus_params ::=  IDENTIFIER:s                                        {: RESULT = Collections.singletonList(s); :}
                    |   IDENTIFIER:s LPAREN params:l RPAREN                 {: RESULT = l; RESULT.add(0, s); :}
                    ;

params   ::= params:l COMMA QUOTEDSTR:s                                     {: RESULT = l; l.add(s); :}
           | params:l COMMA IDENTIFIER:s                                    {: RESULT = l; l.add(s); :}
           | QUOTEDSTR:s                                                    {: RESULT = new ArrayList<String>(); RESULT.add(s); :}
           | IDENTIFIER:s                                                   {: RESULT = new ArrayList<String>(); RESULT.add(s); :}
           ;
                                      
field_spec ::= field_spec:s COLON field_spec_part:s1						{: s.addSpec(s1); RESULT = s; :}
             | field_spec_part:s											{: RESULT = new CompositeSpecification(s); :}
             ;
             
field_spec_simple ::= field_spec_simple:s COLON field_spec_part_simple:s1	{: s.addSpec(s1); RESULT = s; :}
                    | field_spec_part_simple:s								{: RESULT = new CompositeSpecification(s); :}
                    ;

field_spec_part ::= LBRACE field_spec_simple:s RBRACE QUESTION expr:e 		{: s.addConditional(e); RESULT = s; :}
                  | field_spec_part_complex:s								{: RESULT = new CompositeSpecification(s); :}
                  ;
                                    
field_spec_part_complex ::= FIELDSPEC:f SUBFIELDSPEC:sf QUESTION expr:e 	{: RESULT = AbstractSpecificationFactory.makeSingleSpecification(f, sf, e); :}
                          | FIELDSPEC:f POSITION:p QUESTION expr:e			{: RESULT = AbstractSpecificationFactory.makeSingleSpecification(f, p, e); :} 
                          | FIELDSPEC:f QUESTION expr:e						{: RESULT = AbstractSpecificationFactory.makeSingleSpecification(f, null, e); :} 
                          | field_spec_part_simple:s 						{: RESULT = s; :}
                          ;
                          
field_spec_part_simple ::= FIELDSPEC:f SUBFIELDSPEC:sf 						{: RESULT = AbstractSpecificationFactory.makeSingleSpecification(f, sf); :} 
                         | FIELDSPEC:f POSITION:p							{: RESULT = AbstractSpecificationFactory.makeSingleSpecification(f, p); :} 
                         | FIELDSPEC:f 										{: RESULT = AbstractSpecificationFactory.makeSingleSpecification(f, null); :} 
                         ;
                         
expr ::= expr:e1 AND expr:e2 				{: RESULT = new ConditionComposite(e1, e2, FullSym.AND);  :}
       | expr:e1 OR expr:e2					{: RESULT = new ConditionComposite(e1, e2, FullSym.OR);  :} 
       | NOT expr:e							{: RESULT = new ConditionComposite(e, null, FullSym.NOT); :}
       | LPAREN expr:e RPAREN 				{: RESULT = e; :}
       | expr_part:e						{: RESULT = e; :}
       ;
       
expr_part ::= SUBFIELD:s1 op:i value:s2		                {: RESULT = new ConditionSubfield(s1, s2, ((int)i)); :} 
            | IND:s1 op:i value:s2			                {: RESULT = new ConditionIndicator(s1, s2, ((int)i)); :} 
            | POSITION:s1 op:i value:s2		                {: RESULT = new ConditionPosition(s1, s2, ((int)i)); :} 
            | FIELDSPEC:s1 SUBFIELD:s2 op:i value:s3		{: RESULT = new ConditionSubfield(s1, s2, s3, ((int)i)); :} 
            | FIELDSPEC:s1 IND:s2 op:i value:s3			    {: RESULT = new ConditionIndicator(s1, s2, s3, ((int)i)); :} 
            | FIELDSPEC:s1 POSITION:s2 op:i value:s3		{: RESULT = new ConditionPosition(s1, s2, s3, ((int)i)); :} 
            ;
op ::= EQU 									{: RESULT = new Integer(FullSym.EQU); :}
     | NEQ 									{: RESULT = new Integer(FullSym.NEQ); :}
     | MATCH								{: RESULT = new Integer(FullSym.MATCH); :}
     ;
     
value ::= QUOTEDSTR:s						{: RESULT = s; :} 
        | CHAR:s							{: RESULT = s; :}
        | NUMBER:s							{: RESULT = s; :} 
        ;
  
 